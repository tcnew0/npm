{
  "_args": [
    [
      {
        "raw": "cacache@https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
        "scope": null,
        "escapedName": "cacache",
        "name": "cacache",
        "rawSpec": "https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
        "spec": "https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
        "type": "remote"
      },
      "/Users/zkat/Documents/code/npm"
    ]
  ],
  "_from": "https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
  "_id": "cacache@7.0.3",
  "_inCache": true,
  "_location": "/cacache",
  "_phantomChildren": {},
  "_requested": {
    "raw": "cacache@https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
    "scope": null,
    "escapedName": "cacache",
    "name": "cacache",
    "rawSpec": "https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
    "spec": "https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#USER",
    "/",
    "/pacote",
    "/pacote/make-fetch-happen"
  ],
  "_resolved": "https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
  "_shasum": "62e876694cf2c094d319f257b83769ea752278ab",
  "_shrinkwrap": null,
  "_spec": "cacache@https://registry.npmjs.org/cacache/-/cacache-7.0.3.tgz",
  "_where": "/Users/zkat/Documents/code/npm",
  "author": {
    "name": "Kat March√°n",
    "email": "kzm@sykosomatic.org"
  },
  "bugs": {
    "url": "https://github.com/zkat/cacache/issues"
  },
  "cache-version": {
    "content": "2",
    "index": "4"
  },
  "config": {
    "nyc": {
      "exclude": [
        "node_modules/**",
        "test/**"
      ]
    }
  },
  "contributors": [
    {
      "name": "Charlotte Spencer",
      "email": "charlottelaspencer@gmail.com"
    },
    {
      "name": "Rebecca Turner",
      "email": "me@re-becca.org"
    }
  ],
  "dependencies": {
    "bluebird": "^3.4.7",
    "chownr": "^1.0.1",
    "glob": "^7.1.1",
    "graceful-fs": "^4.1.10",
    "lru-cache": "^4.0.2",
    "mississippi": "^1.2.0",
    "mkdirp": "^0.5.1",
    "move-concurrently": "^1.0.0",
    "promise-inflight": "^1.0.1",
    "rimraf": "^2.6.1",
    "ssri": "^4.0.0",
    "unique-filename": "^1.1.0"
  },
  "description": "Fast, fault-tolerant, cross-platform, disk-based, data-agnostic, content-addressable cache.",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "chalk": "^1.1.3",
    "nyc": "^10.2.0",
    "require-inject": "^1.4.0",
    "safe-buffer": "^5.0.1",
    "standard": "^9.0.2",
    "standard-version": "^4.0.0",
    "tacks": "^1.2.2",
    "tap": "^10.3.1",
    "weallbehave": "^1.0.0",
    "weallcontribute": "^1.0.8"
  },
  "files": [
    "*.js",
    "lib"
  ],
  "homepage": "https://github.com/zkat/cacache#readme",
  "keywords": [
    "cache",
    "caching",
    "content-addressable",
    "sri",
    "sri hash",
    "subresource integrity",
    "cache",
    "storage",
    "store",
    "file store",
    "filesystem",
    "disk cache",
    "disk storage"
  ],
  "license": "CC0-1.0",
  "main": "index.js",
  "name": "cacache",
  "optionalDependencies": {},
  "readme": "# cacache [![npm version](https://img.shields.io/npm/v/cacache.svg)](https://npm.im/cacache) [![license](https://img.shields.io/npm/l/cacache.svg)](https://npm.im/cacache) [![Travis](https://img.shields.io/travis/zkat/cacache.svg)](https://travis-ci.org/zkat/cacache) [![AppVeyor](https://ci.appveyor.com/api/projects/status/github/zkat/cacache?svg=true)](https://ci.appveyor.com/project/zkat/cacache) [![Coverage Status](https://coveralls.io/repos/github/zkat/cacache/badge.svg?branch=latest)](https://coveralls.io/github/zkat/cacache?branch=latest)\n\n[`cacache`](https://github.com/zkat/cacache) is a Node.js library for managing\nlocal key and content address caches. It's really fast, really good at\nconcurrency, and it will never give you corrupted data, even if cache files\nget corrupted or manipulated.\n\nIt was originally written to be used as [npm](https://npm.im)'s local cache, but\ncan just as easily be used on its own\n\n## Install\n\n`$ npm install --save cacache`\n\n## Table of Contents\n\n* [Example](#example)\n* [Features](#features)\n* [Contributing](#contributing)\n* [API](#api)\n  * Reading\n    * [`ls`](#ls)\n    * [`ls.stream`](#ls-stream)\n    * [`get`](#get-data)\n    * [`get.stream`](#get-stream)\n    * [`get.info`](#get-info)\n  * Writing\n    * [`put`](#put-data)\n    * [`put.stream`](#put-stream)\n    * [`put*` opts](#put-options)\n    * [`rm.all`](#rm-all)\n    * [`rm.entry`](#rm-entry)\n    * [`rm.content`](#rm-content)\n  * Utilities\n    * [`clearMemoized`](#clear-memoized)\n    * [`tmp.mkdir`](#tmp-mkdir)\n    * [`tmp.withTmp`](#with-tmp)\n  * Integrity\n    * [Subresource Integrity](#integrity)\n    * [`verify`](#verify)\n    * [`verify.lastRun`](#verify-last-run)\n\n### Example\n\n```javascript\nconst cacache = require('cacache')\nconst fs = require('fs')\n\nconst tarball = '/path/to/mytar.tgz'\nconst cachePath = '/tmp/my-toy-cache'\nconst key = 'my-unique-key-1234'\n\n// Cache it! Use `cachePath` as the root of the content cache\ncacache.put(cachePath, key, '10293801983029384').then(integrity => {\n  console.log(`Saved content to ${cachePath}.`)\n})\n\nconst destination = '/tmp/mytar.tgz'\n\n// Copy the contents out of the cache and into their destination!\n// But this time, use stream instead!\ncacache.get.stream(\n  cachePath, key\n).pipe(\n  fs.createWriteStream(destination)\n).on('finish', () => {\n  console.log('done extracting!')\n})\n\n// The same thing, but skip the key index.\ncacache.get.byDigest(cachePath, integrityHash).then(data => {\n  fs.writeFile(destination, data, err => {\n    console.log('tarball data fetched based on its sha512sum and written out!')\n  })\n})\n```\n\n### Features\n\n* Extraction by key or by content address (shasum, etc)\n* [Subresource Integrity](#integrity) web standard support\n* Multi-hash support - safely host sha1, sha512, etc, in a single cache\n* Automatic content deduplication\n* Fault tolerance (immune to corruption, partial writes, process races, etc)\n* Consistency guarantees on read and write (full data verification)\n* Lockless, high-concurrency cache access\n* Streaming support\n* Promise support\n* Pretty darn fast -- sub-millisecond reads and writes including verification\n* Arbitrary metadata storage\n* Garbage collection and additional offline verification\n* Thorough test coverage\n* There's probably a bloom filter in there somewhere. Those are cool, right? ü§î\n\n### Contributing\n\nThe cacache team enthusiastically welcomes contributions and project participation! There's a bunch of things you can do if you want to contribute! The [Contributor Guide](CONTRIBUTING.md) has all the information you need for everything from reporting bugs to contributing entire new features. Please don't hesitate to jump in if you'd like to, or even ask us questions if something isn't clear.\n\nAll participants and maintainers in this project are expected to follow [Code of Conduct](CODE_OF_CONDUCT.md), and just generally be excellent to each other.\n\nPlease refer to the [Changelog](CHANGELOG.md) for project history details, too.\n\nHappy hacking!\n\n### API\n\n#### <a name=\"ls\"></a> `> cacache.ls(cache) -> Promise`\n\nLists info for all entries currently in the cache as a single large object. Each\nentry in the object will be keyed by the unique index key, with corresponding\n[`get.info`](#get-info) objects as the values.\n\n##### Example\n\n```javascript\ncacache.ls(cachePath).then(console.log)\n// Output\n{\n  'my-thing': {\n    key: 'my-thing',\n    integrity: 'sha512-BaSe64/EnCoDED+HAsh=='\n    path: '.testcache/content/deadbeef', // joined with `cachePath`\n    time: 12345698490,\n    metadata: {\n      name: 'blah',\n      version: '1.2.3',\n      description: 'this was once a package but now it is my-thing'\n    }\n  },\n  'other-thing': {\n    key: 'other-thing',\n    integrity: 'sha1-ANothER+hasH=',\n    path: '.testcache/content/bada55',\n    time: 11992309289\n  }\n}\n```\n\n#### <a name=\"ls-stream\"></a> `> cacache.ls.stream(cache) -> Readable`\n\nLists info for all entries currently in the cache as a single large object.\n\nThis works just like [`ls`](#ls), except [`get.info`](#get-info) entries are\nreturned as `'data'` events on the returned stream.\n\n##### Example\n\n```javascript\ncacache.ls.stream(cachePath).on('data', console.log)\n// Output\n{\n  key: 'my-thing',\n  integrity: 'sha512-BaSe64HaSh',\n  path: '.testcache/content/deadbeef', // joined with `cachePath`\n  time: 12345698490,\n  metadata: {\n    name: 'blah',\n    version: '1.2.3',\n    description: 'this was once a package but now it is my-thing'\n  }\n}\n\n{\n  key: 'other-thing',\n  integrity: 'whirlpool-WoWSoMuchSupport',\n  path: '.testcache/content/bada55',\n  time: 11992309289\n}\n\n{\n  ...\n}\n```\n\n#### <a name=\"get-data\"></a> `> cacache.get(cache, key, [opts]) -> Promise({data, metadata, integrity})`\n\nReturns an object with the cached data, digest, and metadata identified by\n`key`. The `data` property of this object will be a `Buffer` instance that\npresumably holds some data that means something to you. I'm sure you know what\nto do with it! cacache just won't care.\n\n`integrity` is a [Subresource\nIntegrity](#integrity)\nstring. That is, a string that can be used to verify `data`, which looks like\n`<hash-algorithm>-<base64-integrity-hash>`.\n\nIf there is no content identified by `key`, or if the locally-stored data does\nnot pass the validity checksum, the promise will be rejected.\n\nA sub-function, `get.byDigest` may be used for identical behavior, except lookup\nwill happen by integrity hash, bypassing the index entirely. This version of the\nfunction *only* returns `data` itself, without any wrapper.\n\n##### Note\n\nThis function loads the entire cache entry into memory before returning it. If\nyou're dealing with Very Large data, consider using [`get.stream`](#get-stream)\ninstead.\n\n##### Example\n\n```javascript\n// Look up by key\ncache.get(cachePath, 'my-thing').then(console.log)\n// Output:\n{\n  metadata: {\n    thingName: 'my'\n  },\n  integrity: 'sha512-BaSe64HaSh',\n  data: Buffer#<deadbeef>\n}\n\n// Look up by digest\ncache.get.byDigest(cachePath, 'sha512-BaSe64HaSh').then(console.log)\n// Output:\nBuffer#<deadbeef>\n```\n\n#### <a name=\"get-stream\"></a> `> cacache.get.stream(cache, key, [opts]) -> Readable`\n\nReturns a [Readable Stream](https://nodejs.org/api/stream.html#stream_readable_streams) of the cached data identified by `key`.\n\nIf there is no content identified by `key`, or if the locally-stored data does\nnot pass the validity checksum, an error will be emitted.\n\n`metadata` and `integrity` events will be emitted before the stream closes, if\nyou need to collect that extra data about the cached entry.\n\nA sub-function, `get.stream.byDigest` may be used for identical behavior,\nexcept lookup will happen by integrity hash, bypassing the index entirely. This\nversion does not emit the `metadata` and `integrity` events at all.\n\n##### Example\n\n```javascript\n// Look up by key\ncache.get.stream(\n  cachePath, 'my-thing'\n).on('metadata', metadata => {\n  console.log('metadata:', metadata)\n}).on('integrity', integrity => {\n  console.log('integrity:', integrity)\n}).pipe(\n  fs.createWriteStream('./x.tgz')\n)\n// Outputs:\nmetadata: { ... }\nintegrity: 'sha512-SoMeDIGest+64=='\n\n// Look up by digest\ncache.get.stream.byDigest(\n  cachePath, 'sha512-SoMeDIGest+64=='\n).pipe(\n  fs.createWriteStream('./x.tgz')\n)\n```\n\n#### <a name=\"get-info\"></a> `> cacache.get.info(cache, key) -> Promise`\n\nLooks up `key` in the cache index, returning information about the entry if\none exists.\n\n##### Fields\n\n* `key` - Key the entry was looked up under. Matches the `key` argument.\n* `integrity` - [Subresource Integrity hash](#integrity) for the content this entry refers to.\n* `path` - Filesystem path relative to `cache` argument where content is stored.\n* `time` - Timestamp the entry was first added on.\n* `metadata` - User-assigned metadata associated with the entry/content.\n\n##### Example\n\n```javascript\ncacache.get.info(cachePath, 'my-thing').then(console.log)\n\n// Output\n{\n  key: 'my-thing',\n  integrity: 'sha256-MUSTVERIFY+ALL/THINGS=='\n  path: '.testcache/content/deadbeef',\n  time: 12345698490,\n  metadata: {\n    name: 'blah',\n    version: '1.2.3',\n    description: 'this was once a package but now it is my-thing'\n  }\n}\n```\n\n#### <a name=\"put-data\"></a> `> cacache.put(cache, key, data, [opts]) -> Promise`\n\nInserts data passed to it into the cache. The returned Promise resolves with a\ndigest (generated according to [`opts.hashAlgorithm`](#hashalgorithm)) after the\ncache entry has been successfully written.\n\n##### Example\n\n```javascript\nfetch(\n  'https://registry.npmjs.org/cacache/-/cacache-1.0.0.tgz'\n).then(data => {\n  return cacache.put(cachePath, 'registry.npmjs.org|cacache@1.0.0', data)\n}).then(integrity => {\n  console.log('integrity hash is', integrity)\n})\n```\n\n#### <a name=\"put-stream\"></a> `> cacache.put.stream(cache, key, [opts]) -> Writable`\n\nReturns a [Writable\nStream](https://nodejs.org/api/stream.html#stream_writable_streams) that inserts\ndata written to it into the cache. Emits an `integrity` event with the digest of\nwritten contents when it succeeds.\n\n##### Example\n\n```javascript\nrequest.get(\n  'https://registry.npmjs.org/cacache/-/cacache-1.0.0.tgz'\n).pipe(\n  cacache.put.stream(\n    cachePath, 'registry.npmjs.org|cacache@1.0.0'\n  ).on('integrity', d => console.log(`integrity digest is ${d}`))\n)\n```\n\n#### <a name=\"put-options\"></a> `> cacache.put options`\n\n`cacache.put` functions have a number of options in common.\n\n##### `opts.metadata`\n\nArbitrary metadata to be attached to the inserted key.\n\n##### `opts.size`\n\nIf provided, the data stream will be verified to check that enough data was\npassed through. If there's more or less data than expected, insertion will fail\nwith an `EBADSIZE` error.\n\n##### `opts.integrity`\n\nIf present, the pre-calculated digest for the inserted content. If this option\nif provided and does not match the post-insertion digest, insertion will fail\nwith an `EINTEGRITY` error.\n\n`hashAlgorithm` has no effect if this option is present.\n\n##### `opts.hashAlgorithm`\n\nDefault: 'sha512'\n\nHashing algorithm to use when calculating the [subresource integrity\ndigest](#integrity)\nfor inserted data. Can use any algorithm listed in `crypto.getHashes()` or\n`'omakase'`/`'„Åä‰ªª„Åõ„Åó„Åæ„Åô'` to pick a random hash algorithm on each insertion. You\nmay also use any anagram of `'modnar'` to use this feature.\n\n##### `opts.uid`/`opts.gid`\n\nIf provided, cacache will do its best to make sure any new files added to the\ncache use this particular `uid`/`gid` combination. This can be used,\nfor example, to drop permissions when someone uses `sudo`, but cacache makes\nno assumptions about your needs here.\n\n##### `opts.memoize`\n\nDefault: null\n\nIf provided, cacache will memoize the given cache insertion in memory, bypassing\nany filesystem checks for that key or digest in future cache fetches. Nothing\nwill be written to the in-memory cache unless this option is explicitly truthy.\n\nThere is no facility for limiting memory usage short of\n[`cacache.clearMemoized()`](#clear-memoized), so be mindful of the sort of data\nyou ask to get memoized!\n\nReading from existing memoized data can be forced by explicitly passing\n`memoize: false` to the reader functions, but their default will be to read from\nmemory.\n\n#### <a name=\"rm-all\"></a> `> cacache.rm.all(cache) -> Promise`\n\nClears the entire cache. Mainly by blowing away the cache directory itself.\n\n##### Example\n\n```javascript\ncacache.rm.all(cachePath).then(() => {\n  console.log('THE APOCALYPSE IS UPON US üò±')\n})\n```\n\n#### <a name=\"rm-entry\"></a> `> cacache.rm.entry(cache, key) -> Promise`\n\nAlias: `cacache.rm`\n\nRemoves the index entry for `key`. Content will still be accessible if\nrequested directly by content address ([`get.stream.byDigest`](#get-stream)).\n\nTo remove the content itself (which might still be used by other entries), use\n[`rm.content`](#rm-content). Or, to safely vacuum any unused content, use\n[`verify`](#verify).\n\n##### Example\n\n```javascript\ncacache.rm.entry(cachePath, 'my-thing').then(() => {\n  console.log('I did not like it anyway')\n})\n```\n\n#### <a name=\"rm-content\"></a> `> cacache.rm.content(cache, integrity) -> Promise`\n\nRemoves the content identified by `integrity`. Any index entries referring to it\nwill not be usable again until the content is re-added to the cache with an\nidentical digest.\n\n##### Example\n\n```javascript\ncacache.rm.content(cachePath, 'sha512-SoMeDIGest/IN+BaSE64==').then(() => {\n  console.log('data for my-thing is gone!')\n})\n```\n\n#### <a name=\"clear-memoized\"></a> `> cacache.clearMemoized()`\n\nCompletely resets the in-memory entry cache.\n\n#### <a name=\"tmp-mkdir\"></a> `> tmp.mkdir(cache, opts) -> Promise<Path>`\n\nReturns a unique temporary directory inside the cache's `tmp` dir. This\ndirectory will use the same safe user assignment that all the other stuff use.\n\nOnce the directory is made, it's the user's responsibility that all files within\nare made according to the same `opts.gid`/`opts.uid` settings that would be\npassed in. If not, you can ask cacache to do it for you by calling\n[`tmp.fix()`](#tmp-fix), which will fix all tmp directory permissions.\n\nIf you want automatic cleanup of this directory, use\n[`tmp.withTmp()`](#with-tpm)\n\n##### Example\n\n```javascript\ncacache.tmp.mkdir(cache).then(dir => {\n  fs.writeFile(path.join(dir, 'blablabla'), Buffer#<1234>, ...)\n})\n```\n\n#### <a name=\"with-tmp\"></a> `> tmp.withTmp(cache, opts, cb) -> Promise`\n\nCreates a temporary directory with [`tmp.mkdir()`](#tmp-mkdir) and calls `cb`\nwith it. The created temporary directory will be removed when the return value\nof `cb()` resolves -- that is, if you return a Promise from `cb()`, the tmp\ndirectory will be automatically deleted once that promise completes.\n\nThe same caveats apply when it comes to managing permissions for the tmp dir's\ncontents.\n\n##### Example\n\n```javascript\ncacache.tmp.withTmp(cache, dir => {\n  return fs.writeFileAsync(path.join(dir, 'blablabla'), Buffer#<1234>, ...)\n}).then(() => {\n  // `dir` no longer exists\n})\n```\n\n#### <a name=\"integrity\"></a> Subresource Integrity Digests\n\nFor content verification and addressing, cacache uses strings following the\n[Subresource\nIntegrity spec](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).\nThat is, any time cacache expects an `integrity` argument or option, it\nshould be in the format `<hashAlgorithm>-<base64-hash>`.\n\nOne deviation from the current spec is that cacache will support any hash\nalgorithms supported by the underlying Node.js process. You can use\n`crypto.getHashes()` to see which ones you can use.\n\n##### Generating Digests Yourself\n\nIf you have an existing content shasum, they are generally formatted as a\nhexadecimal string (that is, a sha1 would look like:\n`5f5513f8822fdbe5145af33b64d8d970dcf95c6e`). In order to be compatible with\ncacache, you'll need to convert this to an equivalent subresource integrity\nstring. For this example, the corresponding hash would be:\n`sha1-X1UT+IIv2+UUWvM7ZNjZcNz5XG4=`.\n\nIf you want to generate an integrity string yourself for existing data, you can\nuse something like this:\n\n```javascript\nconst crypto = require('crypto')\nconst hashAlgorithm = 'sha512'\nconst data = 'foobarbaz'\n\nconst integrity = (\n  hashAlgorithm +\n  '-' +\n  crypto.createHash(hashAlgorithm).update(data).digest('base64')\n)\n```\n\nYou can also use [`ssri`](https://npm.im) to have a richer set of functionality\naround SRI strings, including generation, parsing, and translating from existing\nhex-formatted strings.\n\n#### <a name=\"verify\"></a> `> cacache.verify(cache, opts) -> Promise`\n\nChecks out and fixes up your cache:\n\n* Cleans up corrupted or invalid index entries.\n* Custom entry filtering options.\n* Garbage collects any content entries not referenced by the index.\n* Checks integrity for all content entries and removes invalid content.\n* Fixes cache ownership.\n* Removes the `tmp` directory in the cache and all its contents.\n\nWhen it's done, it'll return an object with various stats about the verification\nprocess, including amount of storage reclaimed, number of valid entries, number\nof entries removed, etc.\n\n##### Options\n\n* `opts.uid` - uid to assign to cache and its contents\n* `opts.gid` - gid to assign to cache and its contents\n* `opts.filter` - receives a formatted entry. Return false to remove it.\n                  Note: might be called more than once on the same entry.\n\n##### Example\n\n```sh\necho somegarbage >> $CACHEPATH/content/deadbeef\n```\n\n```javascript\ncacache.verify(cachePath).then(stats => {\n  // deadbeef collected, because of invalid checksum.\n  console.log('cache is much nicer now! stats:', stats)\n})\n```\n\n#### <a name=\"verify-last-run\"></a> `> cacache.verify.lastRun(cache) -> Promise`\n\nReturns a `Date` representing the last time `cacache.verify` was run on `cache`.\n\n##### Example\n\n```javascript\ncacache.verify(cachePath).then(() => {\n  cacache.verify.lastRun(cachePath).then(lastTime => {\n    console.log('cacache.verify was last called on' + lastTime)\n  })\n})\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zkat/cacache.git"
  },
  "scripts": {
    "benchmarks": "node test/benchmarks",
    "postrelease": "npm publish && git push --follow-tags",
    "prerelease": "npm t",
    "pretest": "standard lib test *.js",
    "release": "standard-version -s",
    "test": "nyc --all -- tap -J test/*.js",
    "test-docker": "docker run -it --rm --name pacotest -v \"$PWD\":/tmp -w /tmp node:latest npm test",
    "update-coc": "weallbehave -o . && git add CODE_OF_CONDUCT.md && git commit -m 'docs(coc): updated CODE_OF_CONDUCT.md'",
    "update-contrib": "weallcontribute -o . && git add CONTRIBUTING.md && git commit -m 'docs(contributing): updated CONTRIBUTING.md'"
  },
  "version": "7.0.3"
}
